---
title: "Using RWR CV See Seed Set Connectivity"
author: "Matthew Lane"
date: "2023-8-24"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using RWR CV See Seed Set Connectivity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# RWR CV
## 1. Introduction
This document descibes the usage of RWR_CV and the parsing of RWR_CV's output. Using RWR_CV we can test the predictive ability of a particular multiplex network with respect to a known set of genes. To run this algorithm, we will need a multiplex object and a geneset. 

## 2. Setup
In order to run `RWR_CV`, we will need an `mpo` object. These are derived from the `RWRtoolkit::RWR_make_multiplex` function.  For this vignette, we will use previously defined multiplex objects. 

### Obtaining the Network
```{r Setup}
library(RWRtoolkit)
```
We'll select an A. thaliana multiplex consisting of 10 layers (for further description of each layer, please click the associated link): 


| Network                                                      | Nodes  | Edges   |
| ------------------------------------------------------------ | ------ | ------- |
| [CoEvolution-DUO (DU) version 0.1](https://github.com/dkainer/RWRtoolkit-data#coevolution-duo-network) | 2,283  | 13,514  |
| [Coexpression Gene-Atlas (GA) version 0.3](https://github.com/dkainer/RWRtoolkit-data#coex-gene-atlas-network) | 7,683  | 84,959  |
| [Knockout Similarity (KS) version 0.3](https://github.com/dkainer/RWRtoolkit-data#knockout-similarity-network) | 1,841  | 94,952  |
| [PPI-6merged (PP) version 0.3](https://github.com/dkainer/RWRtoolkit-data#ppi-6merged-network) | 19,191 | 317,787 |
| [PEN-Diversity (PX) version 0.1](https://github.com/dkainer/RWRtoolkit-data#pen-diversity-network) | 17,907 | 97,819  |
| [Predictive CG Methylation (PY) version 0.1](https://github.com/dkainer/RWRtoolkit-data#predictive-cg-methylation-1001-epigenomes-network) | 13,314 | 76,027  |
| [Regulation-ATRM (RE) version 0.3](https://github.com/dkainer/RWRtoolkit-data#regulation-atrm-network) | 789    | 1,359   |
| [Regulation-Plantregmap (RP) version 0.3](https://github.com/dkainer/RWRtoolkit-data#regulation-plantregmap-network) | 16,014 | 167,851 |
| [Metabolic-AraCyc (RX) version 0.3](https://github.com/dkainer/RWRtoolkit-data#metabolic-aracyc-network) | 2,857  | 21,524  |


```{r Loading}
athal_multiplex_url <- "https://github.com/dkainer/RWRtoolkit-data/raw/main/Comprehensive_Network_AT_d0.5_v02.RData"
athal_multiplex <- url(athal_multiplex_url)

load(athal_multiplex)
```

### Building a "Gold Set"
We will need a "gold set" of genes to test our multiplex network against. These "gold standard" genes are ones that are previously defined as being highly related in some fashion (e.g. genes with the same GO or Mapman description). 

For our "gold set" of genes, we will use the well described and highly conserved Jasmonte pathway genes defined by MapMan (Table S1). We will then need to annotate those genes with a "set", as goldset files follow the format (where the set name is some defining string and the gene ids are strings that match to node names within the multiplex): 


| **Set Name** | **Gene ID** |
|:---------|:-------------|
| goldSet | node1 |
| goldSet | node2 |
| goldSet | node3 |
| goldSet | node4 |

We can create our own gold set file with:
```{r Goldset Creation}
# Define Genes
jasmonate_seed_genes <- c(
	"AT2G44810", "AT1G17420", "AT1G55020", "AT1G67560",
	"AT1G72520", "AT3G22400", "AT3G45140", "AT5G42650",
	"AT1G13280", "AT3G25760", "AT3G25770", "AT3G25780",
	"AT1G09400", "AT1G17990", "AT1G18020", "AT1G76680",
	"AT1G76690", "AT2G06050", "AT1G17380", "AT1G19180",
	"AT1G48500", "AT1G70700", "AT1G72450", "AT1G74950",
	"AT3G17860", "AT3G43440", "AT5G20900"
)
# Add annotations
seed_gene_setname <- rep("jasmonate_mm", length(jasmonate_seed_genes))
seed_gene_df <- data.frame("set" = seed_gene_setname, "seed" = jasmonate_seed_genes)

# Write File
goldset_filename <- "./goldset_jasomonate.tsv"
write.table(seed_gene_df, goldset_filename, sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
```


### Building a "Bronze Set"
For the sake of illustration, we will generate a set with partially connected, and partially randomly sampled genes, which we will refer to as the "bronze set".

The general idea behind creating this bronze set is to illustrate how scoring works with respect to a set of genes that are not well connected within the supplied network. 

We have built our gold set of Jasmonate MapMan described genes above. We will now replace genes known to be related within the Jasmonate description with others randomly sampled within the network: 

```{r Bronze Set Creation}
# Replace 60% of Jasmonate genes with randomly sampled genes
set.seed(42)
`%notin%` <- Negate(`%in%`)

newly_sampled_percentage <- 2 / 3
n_genes_for_sampling <- floor(length(jasmonate_seed_genes) * newly_sampled_percentage)

gene_pool <- nw.mpo$Pool_of_Nodes[ nw.mpo$Pool_of_Nodes %notin% jasmonate_seed_genes ] 

random_sample <- sample(gene_pool, replace = FALSE, size = n_genes_for_sampling)

## Replace:
seed_gene_df$seed[1:length(random_sample)] <- random_sample

random_sample_filename <- "./partially_random_sample_seeds.tsv"
write.table(seed_gene_df, random_sample_filename, row.names = FALSE, col.names = FALSE, quote = FALSE)
```

We now have two sets of genes: one in which there exists known connections between all genes within the set, and another with known connections between only $\frac{1}{3}$ of the genes. Running RWR_CV for both our gold set and our bronze set, we can then compare the outputs. 

# Runing RWR CV
When running RWR_CV, there exist multiple methods in which to test the gene sets with respect to the networks. Users have the ability to select a method of either: 
 - KFold: Each relevant gene R is ranked once. There are K folds with the expectation of R / K left out per fold. 
 
 - Leave One Out (LOO): Each relevant gene R is ranked once in that there are R total folds, with 1 gene left out per fold. 
 
 - Singletons: Each relevant gene R is ranked $R-1$ times. There are R folds, with $R-1$ left out per fold. 

Given the nature of how each method works, the above methods do have differing outputs: 

For each of these, scoring metrics are then used to generate the final tables consisting of: 
- `fullranks`:  These data include the ranks for each particular fold within the k folds for each node within the network. 

- `metrics`: These data include the information from `medianranks` on top of: 
    - True positive (TP): that is, are the ranked genes within median ranks members of the provided gene set
    
    - False positive (FP): Genes that exist within the top median ranked genes, yet not in the provided gene set
    
    - True Negative: TN
    
    - False Negative: FN
    
    - Cumulative Scores for TP / FP / TN / FN as ranks increase.

    - False Positive Rate (FPR):  The cumulative false positive for at row i over the total number of false positives. 

    - Precision:  True Positive / ( True Positive + False Positive)

    - Recall:  True Positive / (True Positive + False Negative) 

- `summary`: The Summary of the k fold output contains: 
  - Fold: The associated fold

  - Value: The Value of the function noted in `measure`

  - Measure: 

    - `P@NumLeftOut`: Percentage of the number of genes left out

    - `AvgPrec`: Average Precision. 

  - Geneset:  The geneset of the associated input genes.


### kFold
With our multiplex, gold and bronze set genes in place, we can run `RWR_CV`. First, let's run `kfold` on the gold set genes to see how well they perform. By using the `kfold` method, genes are randomly split into groups of seeds to see how well those seed groups can recall the left out genes: 

```{r Running kFold}
gold_path <- "goldset_kfold_output"
gold_cv_kfold_output <- RWRtoolkit::RWR_CV(
  data = athal_multiplex_url,
  geneset_path = goldset_filename,
  method = "kfold",
  write_to_file=TRUE,
  plot = TRUE,
  outdir = gold_path
)

bronze_path <- "bronzeset_kfold_output"
bronze_cv_kfold_output <- RWRtoolkit::RWR_CV(
  data = athal_multiplex_url,
  geneset_path = random_sample_filename,
  method = "kfold",
  write_to_file=TRUE,
  plot = TRUE,
  outdir = bronze_path)

```
### RWR_CV Kfold Output Analysis
After running the above two functions, we can see the main difference between the two gene sets in their output metrics: 
### Gold Set
```{r}
head(gold_cv_kfold_output$metrics)
```
In the gold set run, when initially viewing the head of the dataframe, we can see that the top ranked genes from our network are in the validation set of gene (resulting in true positive matches). Additionally, upon visual inspection of the plots, we can see that our ROC curve quickly ranks all genes within the network!

```{r, echo=F, out.width="100%", fig.align="center"}
image_path <- paste(gold_path, "RWR-CV_jasmonate_mm_Comprehensive_Network_AT_d0.5_v02_default.plots.png", sep="/")

knitr::include_graphics(image_path)
```

### Bronze Set
```{r}
head(bronze_cv_kfold_output$metrics)
```
Notice that the Bronze Set , however, our top ranked genes have no true positives. The bronze set has significantly fewer True Positive matches than does the Gold Set. That means that as the random walker traversed the network, it took quite a while to recall the other genes within the set. Additionally this can be illustrated by the plot below:

```{r, echo=F, out.width="100%", fig.align="center"}
image_path <- paste(bronze_path, "RWR-CV_jasmonate_mm_Comprehensive_Network_AT_d0.5_v02_default.plots.png", sep="/")

knitr::include_graphics(image_path)
```


### Leave One Out 
Instead of randomly shuffling the gene set k times for a train/test split, we can remove only one gene from the gene set and see how quickly the random walker can recall that gene. This is done for every gene within the genes set, so if there exist N genes, we will run a random walk N times: 

```{r Running LOO}
gold_path <- "goldset_loo_output"
gold_cv_loo_output <- RWRtoolkit::RWR_CV(
  data = athal_multiplex_url,
  geneset_path = goldset_filename,
  method = "loo",
  write_to_file=TRUE,
  plot = TRUE,
  outdir = gold_path
)

bronze_path <- "bronzeset_loo_output"
bronze_cv_loo_output <- RWRtoolkit::RWR_CV(
  data = athal_multiplex_url,
  geneset_path = random_sample_filename,
  method = "loo",
  write_to_file=TRUE,
  plot = TRUE,
  outdir = bronze_path)


```
### RWR_CV LOO Output Analysis
Now, instead of using our method of separation as kfold, we can leave only 1 node out using LOO: 
### Gold Set
```{r}
head(gold_cv_loo_output$metrics)
```
Similarly to the above output for kfold, we can see that the top ranked genes in the goldset run from our network are in the validation set of genes, resulting in more true positives:  

```{r, echo=F, out.width="100%", fig.align="center"}
image_path <- paste(gold_path, "RWR-CV_jasmonate_mm_Comprehensive_Network_AT_d0.5_v02_default.plots.png", sep="/")

knitr::include_graphics(image_path)
```

### Bronze Set
```{r}
head(bronze_cv_loo_output$metrics)
```
Notice that between on the other hand, however, our top ranked genes have no true positives. The bronze set has significantly fewer True Positive matches than does the Gold Set. Additionally this can be illustrated by the plot below:

```{r, echo=F, out.width="100%", fig.align="center"}
image_path <- paste(bronze_path, "RWR-CV_jasmonate_mm_Comprehensive_Network_AT_d0.5_v02_default.plots.png", sep="/")

knitr::include_graphics(image_path)
```

### Singletons
With our method of separation being "singletons", we leave out all nodes except for 1, and see how well that single node can recall the others within the set:

```{r Running Singletons}
gold_path <- "goldset_singleton_output"
gold_cv_singleton_output <- RWRtoolkit::RWR_CV(
  data = athal_multiplex_url,
  geneset_path = goldset_filename,
  method = "singletons",
  write_to_file=TRUE,
  plot = TRUE,
  outdir = gold_path
)

bronze_path <- "bronzeset_singleton_output"
bronze_cv_singleton_output <- RWRtoolkit::RWR_CV(
  data = athal_multiplex_url,
  geneset_path = random_sample_filename,
  method = "singletons",
  write_to_file=TRUE,
  plot = TRUE,
  outdir = bronze_path)


```
### RWR_CV singleton Output Analysis

### Gold Set
```{r}
head(gold_cv_singleton_output$metrics)
```
In the gold set run, we can see that the top ranked genes from our network are in the validation set of genes, resulting in more true positives:  


```{r, echo=F, out.width="100%", fig.align="center"}
image_path <- paste(gold_path, "RWR-CV_jasmonate_mm_Comprehensive_Network_AT_d0.5_v02_default.plots.png", sep="/")

knitr::include_graphics(image_path)
```

### Bronze Set
```{r}
head(bronze_cv_singleton_output$metrics)
```
Notice that between on the other hand, however, our top ranked genes have no true positives. The bronze set has significantly fewer True Positive matches than does the Gold Set. Additionally this can be illustrated by the plot below:

```{r, echo=F, out.width="100%", fig.align="center"}
image_path <- paste(bronze_path, "RWR-CV_jasmonate_mm_Comprehensive_Network_AT_d0.5_v02_default.plots.png", sep="/")

knitr::include_graphics(image_path)
```


