---
title: "RWR CV"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rwr-cv-example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Average precision vs AUPRC
- This is curious - read up on me 


## TopologicalEnrichment
- Do null distribution fo fake go terms with bullshit random genes in them, then test against the actual output to calculate p value. 
- Do LOO, save, for the futue when you want to do mapman or kegg, then does preceision calculations against go terms that you give it.
    - Could do.... calculate topGO. 
  -David wants to inclue the Oboe file? 
    using ontology index (get ontology then loads an oboe file and makes a DF )

# Netscore: 
## NETSCORE - if you have network layer acting as a gold set you can use it to determine how truthfule the another network is as a biological 
- You can also test how similar two differnt networks are 


Give demo of calculating tau. 

Run netscore on each individual layer w/ go network against all others ( OR some other layer - it's just 1v1 layer a to b )

Explain what the outputs are saying. 

# GGRAPH:  https://paulvanderlaken.com/2017/10/31/network-visualization-with-igraph-and-ggraph/
## 1. Introduction
This document descibes the usage of RWR_CV from the creation of a multiplex network from scratch to the parsing of RWR_CV's output. 

## 2. Setup
In order to run `RWR_CV`, we will need to generate an `mpo` object from the `RWRtoolkit::RWR_make_multiplex`.  An flist is first required to create an `mpo` object. We can generate random graphs using `igraph::erdos.renyi.game`. 

```{r setup}
library(RWRtoolkit)
library(igraph)
```

### a. Network Layer Generation
```{r}
set.seed(42)
layer1 <- igraph::erdos.renyi.game(5, 1/4)
layer2 <- igraph::erdos.renyi.game(20, 1/8)
layer3 <- igraph::erdos.renyi.game(10, 1/3)
```
```{r Fig1, echo=FALSE}
igraph::plot.igraph(layer1)
igraph::plot.igraph(layer2)
igraph::plot.igraph(layer3)
```
Once the networks have been generated, we can save these as an edge list
```{r}

## Function to convert edgelists from graphs and save to file. 
writeEdgelistToFile <- function(filename, layer){
    # Create Edgelist and rename columns 
    edgelist <- data.frame(as_edgelist(layer))
    colnames(edgelist) <- c('node1', 'node2')

    # Generate Weight list of all 1s (i.e. to make network unweighted)
    weights <- rep(1, nrow(edgelist)) 
    edgelist$weights <- weights    

    # save to file
    write.table(edgelist, filename, sep='\t', row.names = FALSE, quote= FALSE)
}

## Writing Layers to File
writeEdgelistToFile('layer1.tsv', layer1)
writeEdgelistToFile('layer2.tsv', layer2)
writeEdgelistToFile('layer3.tsv', layer3)
```
### b. `flist` and Multiplex Generation

To create the multiplex, first we need an flist (i.e. a file containing the file paths, short names, and grouplist ) pointing to our saved files and create our multiplex. We use 1s for all group values because we are making a node-to-node multiplex (i.e. treating all nodes as the same type such as gene to gene). 

```{r}
# Creating the FLIST
fileList <- c('layer1.tsv', 'layer2.tsv', 'layer3.tsv')
shortNameList <- c('L1', 'L2', 'L3')

flistFilePath <- './flistDF.tsv'
groupList <- c(1, 1, 1)   
flistDF <- data.frame(fileList, shortNameList, groupList)
write.table(flistDF, flistFilePath, sep='\t', col.names = FALSE, row.names = FALSE, quote = FALSE)


multiplexNetworkPath <- './toy_network.Rdata'
RWRtoolkit::RWR_make_multiplex(
   flist = flistFilePath,
   output = multiplexNetworkPath,
   verbose = TRUE
 )
```
The RWRtoolkit::RWR_make_multiplex will then generate an output multiplex, saved to `.toy_network.Rdata`.  The file will contain the network variables: 

- `nw.mpo`:     The multiplex object
- `nw.adj`:     The supra-adjacency matrix
- `nw.adjnorm`  The normalized supra-adjacency matrix


### c. Creating Goldset Genes

We can arbitrarily create a goldset of "functionally related" genes. We can designate genes 1, 2, 3, 4 to be in our original gold set given that we know these genes are highly connected within the previously created arbitrary layers (Typically, gold set genes are those annotatedÂ by a similar GO term or exist within the same biochemical pathway). 

```
1 goldSet
2 goldSet
3 goldSet
4 goldSet
```

We can then use our genes 1, 2, 3, 4 as seeds within our network to see how 

```{r}
goldsetGenes <- c(1, 3, 2, 4)
goldsetSetIDs <- c('goldSet', 'goldSet', 'goldSet', 'goldSet')
goldsetDF <- data.frame(goldsetSetIDs, goldsetGenes)

goldsetPath <- './goldsetCV.tsv'
write.table(goldsetDF, goldsetPath, row.names = FALSE, col.names = FALSE, sep='\t', quote=FALSE)
```

## Running RWR_CV 

### 1. Testing Goldset Rankings on a Network

With our multiplex and gold set genes in place, we can run `RWR_CV`. First, let's run `loo` on the gold set genes to see how well they perform: 

```{r}
goldsetCV_looOutput <- RWRtoolkit::RWR_CV(
    dataPath = multiplexNetworkPath,
    genesetPath = goldsetPath,
    method = 'loo', 
    restart = 0.7, 
    tau=c(1,1,1),
    verbose=TRUE
)

goldsetCV_looOutput$medianranks
```

Above, we can see the `$medianranks` output. For each node, the median value is taken across all full ranks (generated from running loo on each of the 4 seed genes).  All data can be seen by accessing the `$fullranks` of the output data. Metrics for each individual node can be found by accessing the `$metrics` data, and metrics for the entire network as a whole can be found under the `$summary` tag. 


### Testing a Network with Gold Sets

Given a particular goldset of genes which are known to be highly correlated you can test how well a network represents those genes. Consider a gold set of genes 8, 18, and 19.  We wish to know whether or not the network generated above well represents these genes. 

First we must create the goldset and save it to a file: 
```{r}
genesetGenes <- c(8, 18, 19)
genesetSetIDs <- c('testGoldSet', 'testGoldSet', 'testGoldSet')
genesetDF <- data.frame(genesetSetIDs, genesetGenes)
goldsetPath <- './testing_genesetCV.tsv'
write.table(genesetDF, goldsetPath, row.names = FALSE, col.names = FALSE, sep='\t', quote=FALSE)
```

We can then test our network by running RWR_CV on this network and evaluating the median ranks: 
```{r}
goldsetCV_singletonsOutput <- RWRtoolkit::RWR_CV(
    dataPath = multiplexNetworkPath,
    genesetPath = goldsetPath,
    method = 'singletons', 
    restart = 0.7, 
    verbose=TRUE, 
    plot=TRUE, 
    outdirPath='./plots'
)

goldsetCV_singletonsOutput$medianranks
```
