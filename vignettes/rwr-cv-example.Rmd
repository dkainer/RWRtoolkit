---
title: "RWR CV"
author: "Matt Lane"
date: "2022-12-05"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RWR CV}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1. Introduction
This document descibes the usage of RWR_CV from the creation of a multiplex network from scratch to the parsing of RWR_CV's output. After the initial set test set is illustrated, real data are then implemented below. 

## 2. Setup
In order to run `RWR_CV`, we will need to generate an `mpo` object from the `RWRtoolkit::RWR_make_multiplex`.  An flist is first required to create an `mpo` object. We can generate random graphs using `igraph::erdos.renyi.game`. 

```{r setup}
library(RWRtoolkit)
library(igraph)
```

### a. Network Layer Generation
```{r}
set.seed(42)
layer1 <- igraph::erdos.renyi.game(5, 1 / 4)
layer2 <- igraph::erdos.renyi.game(20, 1 / 8)
layer3 <- igraph::erdos.renyi.game(10, 1 / 3)
```
```{r Fig1, echo=F, out.width="100%", fig.align="center"}
output <- capture.output({
  V(layer1)$label.cex <- 0.5
  V(layer2)$label.cex <- 0.5
  V(layer3)$label.cex <- 0.5
  
  png('layers.png', width=700, height=350, res=300)
  par(mfrow= c(1,3), mar=c(1,1,1,1))
  igraph::plot.igraph(layer1, main="Layer 1", vertex.size=25)
  igraph::plot.igraph(layer2, main="Layer 2", vertex.size=25)
  igraph::plot.igraph(layer3, main="Layer 3", vertex.size=25)
  dev.off()
})
knitr::include_graphics('layers.png')

```

Once the networks have been generated, we need to save these as an edge list:
```{r}
## Function to convert edgelists from graphs and save to file.
writeEdgelistToFile <- function(filename, layer) {
  # Create Edgelist and rename columns
  edgelist <- data.frame(as_edgelist(layer))
  colnames(edgelist) <- c("node1", "node2")

  # Generate Weight list of all 1s (i.e. to make network unweighted)
  weights <- rep(1, nrow(edgelist))
  edgelist$weights <- weights

  # save to file
  write.table(edgelist, filename, sep = "\t", row.names = FALSE, quote = FALSE)
}

## Writing Layers to File
writeEdgelistToFile("layer1.tsv", layer1)
writeEdgelistToFile("layer2.tsv", layer2)
writeEdgelistToFile("layer3.tsv", layer3)
```

### b. `flist` and Multiplex Generation

To create the multiplex, first we need an flist pointing to our saved files and create our multiplex. An flist is a file that consists of the file paths to each layer, a short name, and its group (se use 1s for all group values because we are making a node-to-node multiplex (i.e. treating all nodes as the same type such as gene to gene).  


| **File Path** | **Short Name**  | **Group**  |
|:----------------|:----------------|:----------------|
| ./layer1.tsv  | L1 |  1 | 
| ./layer2.tsv  | L2 | 1 |
| ./layer3.tsv  | L3 | 1 |


```{r}
# Creating the FLIST
fileList <- c("layer1.tsv", "layer2.tsv", "layer3.tsv")
shortNameList <- c("L1", "L2", "L3")

flistFilePath <- "./flistDF.tsv"
groupList <- c(1, 1, 1)
flistDF <- data.frame(fileList, shortNameList, groupList)
write.table(flistDF, flistFilePath, sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE)

multiplexNetworkPath <- "./toy_network.Rdata"
RWRtoolkit::RWR_make_multiplex(
  flist = flistFilePath,
  output = multiplexNetworkPath,
  verbose = TRUE
)
```

Note: The flist saved to your directory has neither column names nor row names and has no quotations.


The RWRtoolkit::RWR_make_multiplex will then generate an output multiplex, saved to `.toy_network.Rdata`.  The file will contain the network variables: 

- `nw.mpo`:     The multiplex object
- `nw.adj`:     The supra-adjacency matrix
- `nw.adjnorm`  The normalized supra-adjacency matrix


### c. Creating Goldset Genes

We can arbitrarily create a goldset of "functionally related" genes. We can designate genes 1, 2, 3, 4 to be in our original gold set given that we know these genes are highly connected within the previously created arbitrary layers (Typically, gold set genes are those annotatedÂ by a similar GO/Mapman term or exist within the same biochemical pathway). 



| **Gene** | **Set Name** |
|:---------|:-------------|
| 1 | goldSet |
| 2 | goldSet |
| 3 | goldSet |
| 4 | goldSet |

We can then use our genes 1, 2, 3, 4 as seeds within our network to see how 

```{r}
goldsetGenes <- c(1, 3, 2, 4)
goldsetSetIDs <- c("goldSet", "goldSet", "goldSet", "goldSet")
goldsetDF <- data.frame(goldsetSetIDs, goldsetGenes)

goldsetPath <- "./goldsetCV.tsv"
write.table(goldsetDF, goldsetPath, row.names = FALSE, col.names = FALSE, sep = "\t", quote = FALSE)
```
Note: Again, our tsv file contains no column names nor row names. 

## 3. Running RWR_CV 

When running RWR_CV, there exist multiple methods in which to test the gold sets with respect to the networks. Users have the ability to select a method of either: 

 - KFold: Each relevant gene R is ranked once. There are K folds with the expectation of R / K left out per fold. 
 
 - Leave One Out (LOO): Each relevant gene R is ranked once in that there are R total folds, with 1 gene left out per fold. 
 
 - Singletons: Each relevant gene R is ranked $R-1$ times. There are R folds, with $R-1$ left out per fold. 

For each of these, scoring metrics are then used to generate the final tables consisting of: 

- `fullranks`:  These data include the ranks for each particular fold within the k folds for each node within the network. 

- `medianranks`: These data are the median rank data for each particular node over all k folds of the cross validation. 

- `metrics`: These data include the information from `medianranks` on top of: 

    - True positive (TP): that is, are the ranked genes within median ranks members of the provided gene set
    
    - False positive (FP): Genes that exist within the top median ranked genes, yet not in the provided gene set
    
    - True Negative: TN
    
    - False Negative: FN
    
    - Cumulative Scores for TP / FP / TN / FN as ranks increase. 

    - False Positive Rate (FPR):  The cumulative false positive for at row i over the total number of false positives. 

    - Precision:  True Positive / ( True Positive + False Positive)

    - Recall:  True Positive / (True Positive + False Negative) 

- `summary`: The Summary of the k fold output contains: 

  - Fold: The associated fold

  - Value: The Value of the function noted in `measure`

  - Measure: Denotes the type of measure, either:

    - `P@NumLeftOut`: Percentage of the number of genes left out

    - `AvgPrec`: Average Precision. 

  - Geneset:  The geneset of the associated input genes.


### Kfold
With our multiplex and gold set genes in place, we can run `RWR_CV`. First, let's run `kfold` on the gold set genes to see how well they perform. By using `kfold` genes are randomly split into groups of seeds to see how well those seed groups can recall the left out genes: 

```{r}
goldsetCV_kfoldOutput <- RWRtoolkit::RWR_CV(
  data = multiplexNetworkPath,
  geneset_path = goldsetPath,
  method = "kfold",
  folds=2,
  restart = 0.7,
  tau = c(1, 1, 1),
  plot=TRUE,
  write_to_file = TRUE,
  outdir_path = 'testset_kfold'
)
```

```{r, echo=F, out.width="100%", fig.align="center"}
# file renaming here is unnecessary
directory <- 'testset_kfold'
plot_name <- "RWR-CV_goldSet_toy_network.Rdata_default.plots.png"
previous_name <- paste(directory, plot_name, sep="/")
new_name <- paste(directory, "plot.png", sep="/")
mv_command <- paste("mv", previous_name, new_name)
system(mv_command)

image_path <- paste(directory, "plot.png", sep="/")
knitr::include_graphics(image_path)
```




### Leave One Out 
Now, let's run the leave one out method (`loo`). In this method, we extract only one gene from the gene set. This measure how well all of the remaining genes can find that particular individual:

```{r}
goldsetCV_looOutput <- RWRtoolkit::RWR_CV(
  data = multiplexNetworkPath,
  geneset_path = goldsetPath,
  method = "loo",
  restart = 0.7,
  tau = c(1, 1, 1),
  plot=TRUE,
  write_to_file = TRUE,
  outdir_path = 'testset_loo'
)
```

```{r, echo=F, out.width="100%", fig.align="center"}
# file renaming here is unnecessary
directory <- 'testset_loo'
plot_name <- "RWR-CV_goldSet_toy_network.Rdata_default.plots.png"
previous_name <- paste(directory, plot_name, sep="/")
new_name <- paste(directory, "plot.png", sep="/")
mv_command <- paste("mv", previous_name, new_name)
system(mv_command)

image_path <- paste(directory, "plot.png", sep="/")
knitr::include_graphics(image_path)
```


### Singletons

```{r}
goldsetCV_singletonsOutput <- RWRtoolkit::RWR_CV(
  data = multiplexNetworkPath,
  geneset_path = goldsetPath,
  method = "loo",
  restart = 0.7,
  tau = c(1, 1, 1),
  plot=TRUE,
  write_to_file = TRUE,
  outdir_path = 'testset_singletons'
)
```

```{r, echo=F, out.width="100%", fig.align="center"}
# file renaming here is unnecessary
directory <- 'testset_singletons'
plot_name <- "RWR-CV_goldSet_toy_network.Rdata_default.plots.png"
previous_name <- paste(directory, plot_name, sep="/")
new_name <- paste(directory, "plot.png", sep="/")
mv_command <- paste("mv", previous_name, new_name)
system(mv_command)

image_path <- paste(directory, "plot.png", sep="/")
knitr::include_graphics(image_path)
```
