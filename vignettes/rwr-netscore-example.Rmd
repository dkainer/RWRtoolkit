---
title: "RWR Netscore"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RWR Netscore}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Netscore: 
With Netscore, you can test how similar two differnt networks are. For example, if you have network layer acting as a gold set standard, you can use that network to test against another non-gold set network to determine how closely related they are. 


## 1. Introduction
This document descibes the usage of RWR_netscore. This tool performs a network intersect between your input network (`–network`) and a gold truth network (`–gold`). It scores the strength of that intersect with multiple metrics.

## 2. Setup
Unlike other functions in the RWRtoolkit, the `RWR_netscore` function does not requre an `mpo` R object. Both the network layer (`-network`) and the truth network against which you are testing (`-gold`) are evaluated from their edgelist form: `<Source> <Target> <Weight>`. 

In order to deomonstrate `RWR_Netscore`, we will need to generate a network. 

```{r setup}
library(ggplot2)
library(igraph)
library(patchwork)
library(RWRtoolkit)
```

### Network Layer Generation
```{r}
set.seed(42)
nVertices <- 15

# overwrite letters to contain letter combinations for more options
EXTRALETTERS <- c(LETTERS, sapply(LETTERS, function(x) paste0(x, LETTERS)))
goldLayer <- igraph::erdos.renyi.game(nVertices, 1 / 5)
goldLayer <- set_vertex_attr(goldLayer, "name", 1:nVertices, EXTRALETTERS[1:nVertices])

# generate permutation:
sampledVertices <- sample(vcount(goldLayer))
sortedSampledNames <- lapply(sampledVertices, function(x) V(goldLayer)$name[x])

permutedGoldLayer <- permute(goldLayer, sampledVertices)
permutedGoldLayer <- set_vertex_attr(permutedGoldLayer, "name", 1:nVertices, unlist(sortedSampledNames))
```

```{r Fig1, echo=F, out.width="100%", fig.align="center"}
output <- capture.output({
  V(goldLayer)$label.cex <- 0.35
  V(permutedGoldLayer)$label.cex <- 0.35
  
  png('layers.png', width=700, height=350, res=300)
  par(mfrow= c(1,2), mar=c(1,1,1,1))
  igraph::plot.igraph(goldLayer, main="Gold", vertex.size=20, cex.main=0.5)
  igraph::plot.igraph(permutedGoldLayer, main="Permuted ", vertex.size=20, cex.main=0.5)
  dev.off()
})
knitr::include_graphics('layers.png')
```

Once the "truth set" gold network has been generated, we can save this as an edge list:

```{r}
## Function to convert edgelist from graph and save to file.
writeEdgelistToFile <- function(filename, layer) {
  # Create Edgelist and rename columns
  edgelist <- data.frame(as_edgelist(layer))
  colnames(edgelist) <- c("node1", "node2")

  # Generate Weight list of all 1s (i.e. to make network unweighted)
  weights <- rep(1, nrow(edgelist))
  edgelist$weights <- weights

  # save to file
  write.table(edgelist, filename, sep = "\t", row.names = FALSE, quote = FALSE)
}

## Writing Layers to File
writeEdgelistToFile("gold.tsv", goldLayer)
writeEdgelistToFile("permutedGold.tsv", permutedGoldLayer)
```

## 3. Running Netscore 
First and foremost, let's see a perfect intesect by using our gold network as both the gold and the user network: 

```{r}
RWRtoolkit::RWR_netscore(gold = "./gold.tsv", network = "./gold.tsv")
```
We see here we have complete overlap with 100% intersection.

Let's now see what happens when we remove vertices from our network: 

```{r}
testNet <- goldLayer
netscores <- NULL

suppressMessages(
  for (i in 0:nVertices) {
    if (i != 0) {
      vertexForDeletion <- EXTRALETTERS[i]
      vertexForAddition <- EXTRALETTERS[i + nVertices]
      print(paste("Removing node", vertexForDeletion), collapse = ",")

      testNet <- delete.vertices(testNet, vertexForDeletion)
      testNet <- add.vertices(testNet, 1, attr = list(name = vertexForAddition))
      random_target <- sample(V(testNet)$name, 1)

      print(paste("Adding node", vertexForAddition, "with target", random_target), collapse = ",")
      testNet <- add.edges(testNet, c(vertexForAddition, random_target))
    }
    filename <- paste("testNet_", i, ".tsv", sep = "")
    writeEdgelistToFile(filename, testNet)

    netscore <- RWR_netscore(gold = "./gold.tsv", filename)
    netscore$step <- i
    netscores <- rbind(netscores, netscore)
  }
)

netscores
```

Analyzing the output of the `netscores`, we can see that as we remove nodes and their corresponding edges from the network, we can see that the netscore decreases over time. This is expected as we are individually removing gold network nodes and replacing them at each iteration, as illustrated below.  

```{r  out.width="100%", fig.align="center"}
p1 <- ggplot(data = netscores, aes(x = step)) +
  geom_line(aes(y = intersecting_edges), color = "darkred")

p2 <- ggplot(data = netscores, aes(x = step)) +
  geom_line(aes(y = nodes_in_common), color = "forestgreen")

p3 <- ggplot(data = netscores, aes(x = step, y = intersect_perc)) +
  geom_line(color = "steelblue") +
  geom_point()

ggsave(plot = p1 + p2 + p3, file="netscores.png", width=6, height=2, dpi=300)
knitr::include_graphics('netscores.png')
```

## Working with Real Data

Let's take our multiplex layers from the `RWR_make_multiplex` example (however, because Netscore uses the filepaths we need only the layer files, and do not need to compute the whole multiplex): 

```{r}
# An example of a default RWR Make Multiplex with an output "network.Rdata"
extdata.dir <- system.file("example_data", package = "RWRtoolkit")
outdir <- paste(extdata.dir, "/out/rwr_make_multiplex", sep = "")

layers.path <- paste(extdata.dir, "/layers/", sep = "")
layers <- list.files(layers.path)
layer_with_paths <- paste(layers.path, layers, sep = "")
layer_names <- sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(layers))
```

Now, we have our multiplex data, we can test each of the layers against each other to see how well they're connected. We can easily visualize this with a network such that each vertex in this visualization network illustrates a layer, and the edge thickness illustrates how well the edges score with respect to their intersect:

```{r  out.width="100%", fig.align="center"}
# Loading the data
networkEdgeList <- NULL

suppressMessages(
  for (i in 1:length(layers)) {
    sourcePath <- layer_with_paths[i]
    sourceName <- layer_names[i]
    sourceName <- gsub("_", "\n", sourceName)
    for (j in 1:length(layers)) {
      if (i == j) next
      targetPath <- layer_with_paths[j]
      targetName <- layer_names[j]
      targetName <- gsub("_", "\n", targetName)
      
      netscore <- RWR_netscore(sourcePath, targetPath)
      intersectPct <- netscore$intersect_perc

      edgeRow <- list(source = sourceName, target = targetName, weight = intersectPct)
      networkEdgeList <- rbind(networkEdgeList, edgeRow)
    }
  }
)
rownames(networkEdgeList) <- NULL
networkEdgeListDF <- as.data.frame(networkEdgeList)

layerNetwork <- igraph::graph_from_data_frame(networkEdgeListDF)
weights <- unlist(networkEdgeList[, 3]) / 100
scale <- colorRamp(c("cyan", "tomato"))
colorLegend <- apply(scale(weights), 1, function(x) rgb(x[1] / 255, x[2] / 255, x[3] / 255))

#E(layerNetwork)$weight <- weights * 1
E(layerNetwork)$color <- colorLegend
edgeWidth <- lapply(E(layerNetwork)$weight, function(x) x * 0.025)
V(layerNetwork)$label.cex <- 1.5

output <- capture.output({
  png('layers_scores.png', width=700, height=700, res = 100)
    
  plot.igraph(
    layerNetwork, 
    edge.width = edgeWidth,
    layout = igraph::layout.circle,
    edge.curved = seq(-0.5, 0.5,length = ecount(layerNetwork)),
    main = "Interlayer Netscores",
    vertex.label.color="black"
  )
  dev.off()
})
knitr::include_graphics('layers_scores.png')

```

In the above network, we can see that all of our nodes do have some highly intersecting scores. There is nothing specifically wrong with having a low score between layers, however, it is desirable to be sure that your layers at least highly intersect with some other layers within your network (i.e. having a layer with low intersection to all other layers will result in low scores for all nodes within that network during a random walk, assuming the seeds are not located within that layer). 
