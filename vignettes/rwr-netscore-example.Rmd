---
title: "RWR Netscore"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rwr-netscore-example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Netscore: 
If you have network layer acting as a gold set you can use it to determine how truthfule the another network is. 
- You can also test how similar two differnt networks are 


## 1. Introduction
This document descibes the usage of RWR_netscore. This tool performs a network intersect between your input network (`–network`) and a gold truth network (`–gold`). It scores the strength of that intersect with multiple metrics.

## 2. Setup
Unlike other functions in the RWRtoolkit, the `RWR_netscore` function does not requre an `mpo` R object. Both the network layer (`-network`) and the truth network against which you are testing (`-gold`) are evaluated from their edgelist form: `<Source> <Target> <Weight>`. 

In order to deomonstrate `RWR_Netscore`, we will need to generate a network. 

```{r setup}
library(ggplot2)
library(igraph)
library(patchwork)
library(RWRtoolkit)
```

###- Network Layer Generation
```{r}
set.seed(42)
nVertices <- 15

# overwrite letters to contain letter combinations for more options
LETTERS <- c(LETTERS, sapply(LETTERS, function(x) paste0(x, LETTERS)))
goldLayer <- igraph::erdos.renyi.game(nVertices, 1/5)
goldLayer <- set_vertex_attr(goldLayer, "name", 1:nVertices, LETTERS[1:nVertices])

#generate permutation: 
sampledVertices <- sample(vcount(goldLayer))
sortedSampledNames <- lapply(sampledVertices, function(x) V(goldLayer)$name[x])

permutedGoldLayer <- permute(goldLayer, sampledVertices)
permutedGoldLayer <- set_vertex_attr(permutedGoldLayer, "name", 1:nVertices, unlist(sortedSampledNames))
```

```{r Fig1, echo=FALSE}
igraph::plot.igraph(goldLayer)
igraph::plot.igraph(permutedGoldLayer)
```
Once the "truth set" gold network has been generated, we can save this as an edge list:
```{r}
## Function to convert edgelist from graph and save to file.
writeEdgelistToFile <- function(filename, layer){
    # Create Edgelist and rename columns 
    edgelist <- data.frame(as_edgelist(layer))
    colnames(edgelist) <- c('node1', 'node2')

    # Generate Weight list of all 1s (i.e. to make network unweighted)
    weights <- rep(1, nrow(edgelist)) 
    edgelist$weights <- weights    

    # save to file
    write.table(edgelist, filename, sep='\t', row.names = FALSE, quote= FALSE)
}

## Writing Layers to File
writeEdgelistToFile('gold.tsv', goldLayer)
writeEdgelistToFile('permutedGold.tsv', permutedGoldLayer)
```

## 3. Running Netscore 
First and foremost, let's see a perfect intesect by using our gold network as both the gold and the user network: 

```{r}
RWRtoolkit::RWR_netscore(gold = './gold.tsv',network = './gold.tsv')
```
We see here we have complete overlap with 100% intersection.

Let's now see what happens when we remove vertices from our network: 

```{r}
testNet <- goldLayer
netscores <- NULL

for (i in 0:nVertices) {
  if (i != 0){
    vertexForDeletion <- LETTERS[i]
    vertexForAddition <- LETTERS[i+nVertices]
    print(paste('Removing node', vertexForDeletion))
    testNet <- delete.vertices(testNet, vertexForDeletion)
    testNet <- add.vertices(testNet, 1, attr= list(name=vertexForAddition))
    random_target <- sample(V(testNet)$name, 1)
    print(paste('Adding node', vertexForAddition, 'with target', random_target ))
    testNet <- add.edges(testNet, c(vertexForAddition, random_target))
  }
  filename <- paste('testNet_',i,'.tsv',sep='')
  writeEdgelistToFile(filename, testNet)
  
  igraph::plot.igraph(testNet)
  netscore <- RWR_netscore(gold='./gold.tsv', filename) 
  netscore$step <- i
  netscores <- rbind(netscores, netscore) 
}
  
netscores
```

Analyzing the output of the `netscores`, we can see that as we remove nodes and their corresponding edges from the network, we can see that the netscore decreases over time. This is expected as we are individually removing gold network nodes and replacing them at each iteration, as illustrated below.  

```{r}
p1 <- ggplot(data=netscores, aes(x=step)) + 
  geom_line(aes(y=intersecting_edges), color='darkred') 

p2 <- ggplot(data=netscores, aes(x=step)) + 
  geom_line(aes(y=nodes_in_common), color='forestgreen') 

p3 <- ggplot(data=netscores, aes(x=step, y=intersect_perc)) +
  geom_line(color = "steelblue")+
  geom_point()

p1 + p2 + p3
```

## Working with Real Data

Let's take our multiplex layers from the `RWR_make_multiplex` example (however, because Netscore uses the filepaths we need only the layer files, and do not need to compute the whole multiplex): 

```{r}
# An example of a default RWR Make Multiplex with an output "network.Rdata"
extdata.dir <- system.file("example_data", package="RWRtoolkit")
outdir <- paste(extdata.dir, '/out/rwr_make_multiplex', sep='')

layers.path <- paste(extdata.dir, '/layers/', sep='')
layers <- list.files(layers.path)
layer_with_paths <- paste(layers.path, layers, sep='')
layer_names <- sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(layers))
```

Now, we have our multiplex data, we can test each of the layers against each other to see how well they're connected. We can easily visualize this with a network such that each vertex is a layer, and the edge thickness illustrates how well the edges score with respect to their intersect:

```{r}
# Loading the data
networkEdgeList <- NULL

for (i in 1:length(layers)){
    sourcePath <- layer_with_paths[i]
    sourceName <- layer_names[i]
    
    for (j in 1:length(layers)){
      if (i == j) next
      targetPath <- layer_with_paths[j]
      targetName <- layer_names[j]
      
      netscore <- RWR_netscore(sourcePath, targetPath)
      intersectPct <- netscore$intersect_perc
      
      edgeRow <- list(source=sourceName, target=targetName, weight=intersectPct)
      networkEdgeList <- rbind(networkEdgeList, edgeRow)      
    }
}
rownames(networkEdgeList) <- NULL
networkEdgeListDF <- as.data.frame(networkEdgeList)

layerNetwork <- igraph::graph_from_data_frame(networkEdgeListDF)
weights <- unlist(networkEdgeList[,3 ]) / 100
scale <- colorRamp(c('cyan','tomato'))
colorLegend <- apply(scale(weights), 1, function(x) rgb(x[1]/255,x[2]/255,x[3]/255))

E(layerNetwork)$weight <- weights * 5
E(layerNetwork)$color <- colorLegend

plot.igraph(layerNetwork, edge.width=E(layerNetwork)$weight, layout=igraph::layout_in_circle(layerNetwork))
```

In the above network, we can see that all of our nodes do have some highly intersecting scores. There is nothing specifically wrong with having a low score between layers, however, it is desirable to be sure that your layers at least highly intersect with some other layers within your network (i.e. having a layer with low intersection to all other layers _could_ likely result in low scores for all nodes within that network during a random walk). 




todo
show INTERSECTION OF PERMUTED**



In CV: look at full ranks will have the ranked genes with respect to the seed genes. You'll have length(V(g)) * length(seeds)

ping kyle to go over loo junks

